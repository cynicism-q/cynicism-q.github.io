<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[字符串函数的实现(指针)]]></title>
    <url>%2F2018%2F03%2F20%2Fstring%2F</url>
    <content type="text"><![CDATA[字符串的实现(指针) 模拟实现strlen 模拟实现strcpy 模拟实现strcat 模拟实现strstr 模拟实现strcmp 模拟实现memcpy 模拟实现memmove strlen函数的实现(3种)strlen函数的原型 size_t strlen(const char *string)size_t是unsigned int型的，实际使用int，详细情况请查看CSDN strlen函数的实现 1、计数器的方法12345678910111213141516171819#include &lt;stdio.h&gt;int my_strlen(const char *arr)&#123; int count = 0; while(*arr) &#123; arr++; count++; &#125; return count;&#125;int main()&#123; char arr[] = &quot;abcdef&quot;; printf(&quot;%d\n&quot;,my_strlen(arr)); return 0;&#125; 2、递归的方法123456789101112131415#include &lt;stdio.h&gt;int my_strlen(const char *str)&#123; if(*str == &apos;\0&apos;) return 0; else return 1+my_strlen(str+1);&#125;int main()&#123; char arr[] = &quot;abcdef&quot;; printf(&quot;%d\n&quot;,my_strlen(arr)); return 0;&#125; 3、123456789101112131415#include &lt;stdio.h&gt;int my_strlen(const char * str)&#123; char *p = s; while(*p != &apos;\0&apos;) p++; return p-s;&#125;int main()&#123; char arr[] = &quot;abcdef&quot;; printf(&quot;%d\n&quot;,my_strlen(arr)); return 0;&#125; strcpy函数的实现strcpy函数的原型char strcpy(char dest,const char * src)123456789101112131415161718192021#include &lt;stdio.h&gt;char *my_strcpy(char *dst, const char *src)&#123; char * ret = dst; while(*dst != &apos;\0&apos;) &#123; *dst = *src; dst++; src++; &#125; return ret;&#125;int main()&#123; char arr[10] = &quot;abcdef&quot;; char brr[10] = &quot;ghik&quot;; printf(&quot;%s\n&quot;,my_strcpy(arr,brr)); return 0;&#125; strcat函数的实现123456789101112131415161718192021222324#include &lt;assert.h&gt;char *my_strcat(char *dst,const char * src)&#123; char *ret = dst; assert(dst != NULL); assert(src != NULL); while(*dst) &#123; dst++; &#125; while(*dst++ = *src++) &#123; ; &#125; return ret;&#125;int main()&#123; char arr[20] = &quot;hello word!&quot;; char brr[10] = &quot; nihao!&quot;; printf(&quot;%s\n&quot;,my_strcat(arr,brr)); return 0;&#125; strstr字符串查找函数123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;char *my_strstr(const char *str1,const char *str2)&#123; char *p = (char *)str1; char *pp = (char *)str1; char *q = (char *)str2; char *qq = (char *)str2; while(*pp != &apos;\0&apos;&amp;&amp; *qq != &apos;\0&apos;) &#123; pp = p; qq = q; while(*pp &amp;&amp; *qq &amp;&amp; *pp == *qq) &#123; pp++; qq++; &#125; if(!*qq) &#123; return p; &#125; else if(!*pp) &#123; return NULL; &#125; p++; &#125; return NULL;&#125;int main()&#123; const char* p =&quot;aabbcc123abcdef&quot;; const char* q = &quot;123abcd&quot;; printf(&quot;%s\n&quot;,my_strstr(p,q)); return 0;&#125; memcpy拷贝函数()memcpy函数出现的一些问题，如果s源内存区与d目标内存区有重叠部分会出现错误1234567891011121314151617181920212223#include &lt;stdio.h&gt;void *my_memcpy(void *dst,const void * src,int size)&#123; void * ret = dst; char *p = (char *)dst; char *q = (char *)src; while(size--) &#123; *p = *q; p++; q++; &#125; return ret;&#125;int main()&#123; char a[] = &quot;abcde&quot;; //char b[8]; //my_memcpy(a+1,a,sizeof(a));//次行代码运行结果与预期的不一样，结果全a my_memcpy(a,a+1,sizeof(a)); return 0; ##memmove函数(拷贝函数)解决memcpy函数的不足，重叠区域的问题1234567891011121314151617181920212223242526272829303132333435#include &lt;string.h&gt;void *my_memmove(void *dst,const void * src,int size)&#123; void * ret = dst; char *p = (char*)dst; char *q = (char*)src; if(q &lt; p &amp;&amp; q +size &gt; p) &#123; p = p + size - 1; q = q + size - 1; while(size--) &#123; *p = *q; p--,q--; &#125; &#125; else &#123; while(size--) &#123; *p = *q; p++,q++; &#125; &#125; return ret;&#125;int main()&#123; char a[8] = &quot;abcdef&quot;; //如果把a-&gt;a+1;则这里a[]括号里面至少为字符串长度加一 //char b[10]; my_memmove(a+1,a,strlen(a)+1); return 0;&#125;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>字符串函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数的调用过程(栈帧)]]></title>
    <url>%2F2018%2F03%2F12%2Ftt%2F</url>
    <content type="text"><![CDATA[函数的调用过程（栈帧）一、什么是栈帧1、栈帧的概念1、首先引入百度百科的经典解释：“栈帧也叫过程活动记录，是编译器用来实现过程函数调用的一种数据结构。”。2、栈帧表示程序的函数调用记录，而栈帧又是记录在栈上面，很明显栈上保持了N个栈帧的实体，（实际上我们这里说的栈帧是软件上的概念，据说有硬件概念，不是很了解），那就可以说栈帧将分割成了N个记录块，但是这些记录块大小不是固定不变的，因为栈不仅保存诸如：函数入参，出参，返回地址和上一个栈帧的栈底指针等信息，还保存了函数内部的自动变量，因此不是所有的栈帧的大小都是相同。 2、代码分析栈帧12345678910111213141516#include &lt;stdio.h&gt;int Add(int x, int y)&#123; int z = 0; z = x + y; return z;&#125;int main()&#123; int a = 10; int b = 20; int ret = Add(a,b); printf(&quot;ret = %d\n&quot;,ret); return 0;&#125; 而我们发现其实main函数在__tmainCRTStartup函数中调用，而__tmainCRTStartup函数是在mainCRTStartup被调用。 我们知道每一次函数调用都是一个过程。这个过程我们通常称为：函数的调用过程。这个过程要为函数开辟空间，用于本次函数的调用中临时变量的保存、现场保护。这块栈空间我们称之为函数栈帧。 main函数并不是程序执行的第一个函数，但它是我们逻辑的入口函数。 而栈帧的维护我们必须了解ebp和esp两个寄存器。在函数调用的过程中这两个寄存器存放了维护这个栈的栈底和栈顶指针。 3、通过栈帧修改ret返回的地址测试环境vc6.01234567891011121314151617181920212223242526272829303132333435363738394041# include &lt;stdio.h&gt;# include &lt;windows.h&gt;void *ret = NULL;void bug()&#123; int first = 0; int *p = &amp;first; p+=2; *p= (int)ret; printf(&quot;I am a bug...\n&quot;);&#125;int myfun(int x,int y)&#123; int *p = &amp;x; p--; ret = *p; *p = bug; printf(&quot;run myfun...!\n&quot;); return 0; &#125;int main()&#123; int a = 0xaaaaaaaa; int b = 0xbbbbbbbb; int c; printf(&quot;main run...\n&quot;); c = myfun(a,b); &#125; printf(&quot;you should run here!\n&quot;); printf(&quot;res : %d\n&quot;,c); system(&quot;pause&quot;); return 0;&#125; 运行结果如图： 但是一按回车就会报错，在myfun函数中，本myfun函数执行完成，ret就会将弹出回到main函数的指令，可是通过我们修改把返回指令地址修改为bug函数，myfun函数执行完后，直接执行bug函数，由于执行bug函数没有使用call来调用，所以就没有将下一条指令的地址压入栈中，但是返回是却ret弹出了一个指令，导致最后回到main函数的栈帧大小不同于开始，所以会出现错误。修改，从ESP出多弹出了一个地址空间，所以ESP比之前大4，只要给ESP-4即可。在返回主函数后加一句汇编指令12345678910111213141516171819202122232425262728293031323334353637383940414243# include &lt;stdio.h&gt;# include &lt;windows.h&gt;void *ret = NULL;void bug()&#123; int first = 0; int *p = &amp;first; p+=2; *p= (int)ret; printf(&quot;I am a bug...\n&quot;);&#125;int myfun(int x,int y)&#123; int *p = &amp;x; p--; ret = *p; *p = bug; printf(&quot;run myfun...!\n&quot;); return 0; &#125;int main()&#123; int a = 0xaaaaaaaa; int b = 0xbbbbbbbb; int c; printf(&quot;main run...\n&quot;); c = myfun(a,b); __asm&#123; sub esp,4; //给esp减四 &#125; printf(&quot;you should run here!\n&quot;); printf(&quot;res : %d\n&quot;,c); system(&quot;pause&quot;); return 0;&#125; 回车正确！]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>栈帧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
